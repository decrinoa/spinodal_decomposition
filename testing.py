# -*- coding: utf-8 -*-
"""

Created on Wed Oct  16 16:45:43 2024

@author: decrinoa

"""

import Cahn_Hilliard
import configparser
import numpy as np
import pandas as pd
import os
from hypothesis import strategies as st
from hypothesis import given

config = configparser.ConfigParser()
config.read('config_test.ini')

Nx = config['settings']['Nx']
Ny = config['settings']['Ny']
dx = config['settings']['dx']
dy = config['settings']['dy']

nstep = config['settings']['nstep']
nprint = config['settings']['nprint']
dtime = config['settings']['dtime']

# Random Seed
seed = config['settings']['seed']

# Material specific parameters
c0 = config['material']['c0']
dc = config['material']['dc']
mobility = config['material']['mobility']
grad_coef = config['material']['grad_coef']
A = config['material']['A'] 

Nx = int(Nx)
Ny = int(Ny)
dx = float(dx)
dy = float(dy)

nstep = int(nstep)
nprint = int(nprint)
dtime = float(dtime)
    
seed = int(seed)

c0 = float(c0)
dc = float(dc)
mobility = float(mobility)
grad_coef = float(grad_coef)
A = float(A)

################################add_fluctuation################################
 
# Initialization of the random seed 
np.random.seed(seed)

def test_add_fluctuation_zero_amplitude():
    """
    This test verifies that when the amplitude of fluctuations (dc) is set to
    zero, the output concentration matrix is filled with the base concentration
    value (c0) for all elements. 

    Parameters:
    ----------
    None

    Assertions:
    --------
    - Asserts that the output from add_fluctuation is a 2D array 
      of shape (Ny, Nx) where all elements are equal to c0.
    """
    c0 = 0.5
    dc = 0.0
    result = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    expected = np.full((Ny, Nx), c0)
    
    assert np.array_equal(result, expected)

@given(Nx=st.integers(1,Nx), Ny=st.integers(1,Ny), 
       c0=st.floats(0, c0), dc=st.floats(0, dc))
def test_add_fluctuation_shape(Nx, Ny, c0, dc):
    """
    This test verifies that the output of the 'add_fluctuation' function 
    has the same shape as the input column and row 'Nx', 'Ny'.

    Parameters:
    ----------
    Nx : The number of columns in the concentration matrix. 
         Must be >= 1 than and <= than Nx in configuration file.
       
    Ny : The number of rows in the concentration matrix. 
         Must be >= than 1 and <= than Ny in configuration file.

    c0 : The base concentration value around which fluctuations will occur. 
         Must >= than 0 and <= than c0 in configuration file.
       
    dc : The amplitude of the fluctuations added to the base concentration. 
         Must >= than 0 and <= than dc in configuration file.
         
    Assertions:
    -----------
    - Asserts that the shape of the output from 'add_fluctuation' 
      matches the shape of the input values for column and row 'Nx', 'Ny'.
    """
    result = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    
    assert result.shape == (Ny, Nx)
 
@given(Nx=st.integers(1,Nx), Ny=st.integers(1,Ny), 
       c0=st.floats(0, c0), dc=st.floats(-dc, dc))
def test_add_fluctuation_boundaries(Nx,Ny,c0,dc):
    """
    This test ensures that the concentration values generated by the 
    'add_fluctuation' function are within specified bounds. 
    The bounds are defined from the expression of 'add_fluctuation', 
    namely as the initial concentration 'c0' 
    plus or minus half of the fluctuation range 'dc'.

    Parameters:
    ----------
    Nx : The number of columns in the concentration matrix. 
         Must be >= than 1 and <= than Nx in configuration file.
       
    Ny : The number of rows in the concentration matrix. 
         Must be >= than 1 and <= than Ny in configuration file.
       
    c0 : The base concentration value around which fluctuations will occur. 
         Must >= than 0 and <= than c0 in configuration file.
       
    dc : The amplitude of the fluctuations added to the base concentration. 
         Must >= than 0 and <= than dc in configuration file.

    Assertions:
    -----------
    - Asserts that all concentration values are greater than or equal to 
      the minimum value obtained from the expression of 'add_fluctuation'.
    - Asserts that all concentration values are are lower than or equal to 
      the maximum value obtained from the expression of 'add_fluctuation'.
    """
    result = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    
    if dc >= 0:
       lower_bound = c0 - dc*(0.5)
       upper_bound = c0 + dc*(0.5)
       
       assert np.all(result >= lower_bound)
       assert np.all(result <= upper_bound)
       
    else:
        lower_bound = c0 + dc*(0.5)
        upper_bound = c0 - dc*(0.5)
        
        assert np.all(result >= lower_bound)
        assert np.all(result <= upper_bound)

##############################chemical_potential##############################

def test_chemical_potential_zero_concentration():
    """
    This test checks that the chemical potential is zero when the
    concentration is zero, regardless of the value of A. 
    The case c = 0.0 is a zero of the function 'chemical_potential'.
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given a concentration value equal to zero 
      the chemical potential value is also zero
    """
    c = 0.0
    expected = 0.0
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)

def test_chemical_potential_full_concentration():
    """
    This test checks that the chemical potential is zero when the
    concentration is one, regardless of the value of A.
    The case c = 1.0 is a zero of the function 'chemical_potential'.
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given a concentration value equal to one 
      the chemical potential value is zero
    """
    c = 1.0
    expected = 0.0
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)
    
def test_chemical_potential_half_concentration():
    """
    This test checks that the chemical potential is zero when the
    concentration is 0.5, regardless of the value of A.
    The case c = 0.5 is a zero of the function 'chemical_potential'.
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given a concentration value equal to 0.5 
      the chemical potential value is zero
    """
    c = 0.5
    expected = 0.0
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)

def test_chemical_potential_positive():
    """
    This test checks the chemical potential when the concentration is
    0.25 and A is 1.0. The expected output is 0.1875.
    The case c = 0.25 is near the local maximum of the function 'chemical_potential'
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given a concentration value equal to 0.25 
      the chemical potential value is 0.1875, near the local maximum.
    """
    c = 0.25
    expected = 0.1875
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)

def test_chemical_potential_negative():
    """
    This test checks the chemical potential when the concentration is
    0.75 and A is 1.0. The expected output is -0.1875.
    The case c = 0.75 is near the local minimum of the function 'chemical_potential'
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given a concentration value equal to 0.75
      the chemical potential value is -0.1875, near the local minimum.
    """
    c = 0.75
    expected = -0.1875
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)
    
def test_chemical_potential_zero_A():
    """
    This test verifies that the chemical potential is zero when A is
    set to zero, regardless of the concentration value. The expected
    output is 0.0.
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that given A equal to 0.0
      the chemical potential value is also 0.0.
    """
    c = 0.24
    A = 0.0
    expected = 0.0
    
    assert np.isclose(Cahn_Hilliard.chemical_potential(c, A), expected)

@given(c=st.floats(0, 1))
def test_chemical_potential_boundaries(c):
    """
    This test ensures that the chemical potential values calculated by the 
    'chemical_potential' function are within specified bounds. 
    The bounds are defined from the expression of 'chemical_potential', 
    where the maxima condition is 'c = 0.5 - 1/(2*sqrt(3))' 
    and the minima condition is 'c = 0.5 + 1/(2*sqrt(3))'.

    Parameters:
    ----------   
    c : The concentration value generated between 0 and 1.
       
    Assertions:
    -----------
    - Asserts that all chemical potential values are are greater than or equal to 
      the minimum value obtained from the expression of 'chemical_potential'.
    - Asserts that all chemical potential values are are lower than or equal to 
      the maximum value obtained from the expression of 'chemical_potential'.
    """
    c_max = 0.5 - 1/(2*np.sqrt(3))
    c_min = 0.5 + 1/(2*np.sqrt(3))
    lower_bound = Cahn_Hilliard.chemical_potential(c_min, A)
    upper_bound = Cahn_Hilliard.chemical_potential(c_max, A)
    result = Cahn_Hilliard.chemical_potential(c, A)
    
    assert np.all(result >= lower_bound)
    assert np.all(result <= upper_bound)


@given(Nx=st.integers(1,Nx), Ny=st.integers(1,Ny))
def test_chemical_potential_shape(Nx, Ny):
    """
    This test verifies that the output of the 'chemical_potential' function 
    has the same shape as the input concentration matrix 'c'.

    Parameters:
    ----------
    Nx : The number of columns in the concentration matrix. 
         Must be >= 1 than and <= than Nx in configuration file.
       
    Ny : The number of rows in the concentration matrix. 
         Must be >= than 1 and <= than Ny in configuration file.

    Assertions:
    -----------
    - Asserts that the shape of the output from 'chemical_potential' 
      matches the shape of the input concentration matrix 'c'.
    """
    c = np.random.rand(Ny, Nx)
    result = Cahn_Hilliard.chemical_potential(c, A)
    
    assert result.shape == c.shape

#################################my_laplacian#################################

def test_my_laplacian_value():
    """
    This test verifies that the Laplacian operator is correctly applied 
    to a given concentration matrix, which is defined as:
    c = [[1, 2, 1],
         [2, 3, 2],
         [1, 2, 1]]
    The expected output after applying the Laplacian is:
    expected = [[2, -1, 2],
                [-1, -4, -1],
                [2, -1, 2]]
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that the result of my_laplacian is close to the expected output.
    """
    c = np.array([[1, 2, 1],
                  [2, 3, 2],
                  [1, 2, 1]])
    expected = np.array([[2, -1, 2],
                         [-1, -4, -1],
                         [2, -1, 2]])
    result = Cahn_Hilliard.my_laplacian(c, dx, dy)
    
    assert np.allclose(result, expected)

def test_my_laplacian_uniform():
    """
    This test verifies that the Laplacian operator is correctly applied 
    to a uniform concentration matrix, which is defined as:
    c = [[1, 1, 1],
         [1, 1, 1],
         [1, 1, 1]]
    The expected output after applying the Laplacian is a zero matrix:
    expected = [[0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]]
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that the result of my_laplacian matches the expected zero matrix.
    """
    c = np.array([[1, 1, 1],
                  [1, 1, 1],
                  [1, 1, 1]])
    expected = np.array([[0, 0, 0],
                         [0, 0, 0],
                         [0, 0, 0]])
    
    result = Cahn_Hilliard.my_laplacian(c, dx, dy)
    
    assert np.allclose(result, expected)

def test_my_laplacian_linear_gradient():
    """
    This test verifies that the Laplacian operator is correctly applied 
    to a linear gradient concentration matrix, which is defined as:
    c = [[1, 2, 3],
         [1, 2, 3],
         [1, 2, 3]]
    The expected output after applying the Laplacian is:
    expected = [[3, 0, -3],
                [3, 0, -3],
                [3, 0, -3]]
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that the result of my_laplacian is close to the expected output.
    """
    c = np.array([[1, 2, 3],
                  [1, 2, 3],
                  [1, 2, 3]])
    expected = np.array([[3, 0, -3],
                         [3, 0, -3],
                         [3, 0, -3]])
    result = Cahn_Hilliard.my_laplacian(c, dx, dy)
    
    assert np.allclose(result, expected)    

@given(Nx=st.integers(1,Nx), Ny=st.integers(1,Ny), 
       dx=st.floats(1.0,dx), dy=st.floats(1.0,dy))
def test_my_laplacian_shape(Nx, Ny, dx, dy):
    """
    This test verifies that the output of the 'my_laplacian' function 
    has the same shape as the input concentration matrix 'c'.

    Parameters:
    ----------
    Nx : The number of columns in the concentration matrix. 
         Must be >= 1 than and <= than Nx in configuration file.
       
    Ny : The number of rows in the concentration matrix. 
         Must be >= than 1 and <= than Ny in configuration file.
         
    dx : The spacing between points in the x-direction. 
         Must be >= than 0.1 and <= than dx in configuration file.
    
    dy : The spacing between points in the y-direction. 
         Must be >= than 0.1 and <= than dy in configuration file.
    
    Assertions:
    -----------
    - Asserts that the shape of the output from 'my_laplacian' 
      matches the shape of the input concentration matrix 'c'.
    """
    c = np.random.rand(Ny, Nx)
    result = Cahn_Hilliard.my_laplacian(c, dx, dy)
    
    assert result.shape == c.shape    

###############################evolve_simulation###############################    
    
def test_evolve_simulation_basic_function():
    """
    This test verifies that the `evolve_simulation` function runs correctly for a
    specified number of time steps and prints results at the correct intervals.
    
    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that the length of the results matches the expected number 
      of printed steps.
    - Asserts that the shape of the returned concentration and 
      chemical potential arrays match the shape of the initial concentration array.
    """
    c_initial = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    nstep = 100
    nprint = 50
    dtime = 0.01

    results = Cahn_Hilliard.evolve_simulation(c_initial, nstep, nprint, dtime, 
                                              mobility, grad_coef, A, dx, dy)
    
    # Check that results have the expected length
    assert len(results) == nstep // nprint
    
    # Check the shape of the returned concentration arrays
    for time, c, mu_c in results:
        assert c.shape == c_initial.shape 
        assert mu_c.shape == c_initial.shape


def test_evolve_simulation_progress():
    """
    This test ensures that the concentration and the chemical potential change 
    after a simulation run. It compares the values of initial concentration and
    chemical potential with the final concentration and chemical potential
    to verify that they are not the same, indicating that the simulation 
    has produced some evolution.

    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that the initial and final concentration arrays are not similar.
    - Asserts that the initial and final chemical potential arrays are not similar.
    """
    c_initial = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    initial_concentration = np.copy(c_initial)

    results = Cahn_Hilliard.evolve_simulation(c_initial, nstep, nprint, dtime, 
                                              mobility, grad_coef, A, dx, dy)
    final_concentration = results[-1][1]
    
    assert not np.allclose(initial_concentration, final_concentration)
    
    initial_chemical_potential = results[1][2]
    final_chemical_potential = results[-1][2]
    
    assert not np.allclose(initial_chemical_potential, final_chemical_potential)

def test_evolve_simulation_zero_mobility():
    """
    This test verifies that when the mobility parameter is zero, 
    the concentration remains unchanged throughout the simulation. 
    It checks that the concentration arrays returned in the results
    are all equal to the initial concentration.

    Parameters:
    ----------
    None
    
    Assertions:
    -----------
    - Asserts that any concentration array in the results is similar 
      to the initial concentration.
    """
    c_initial = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    initial_concentration = np.copy(c_initial)
    results_zero_mobility = Cahn_Hilliard.evolve_simulation(c_initial, 
                                                            nstep, nprint, dtime, 
                                                            0.0, grad_coef, A, 
                                                            dx, dy)

    # Check that concentration remains the same due to zero mobility
    for time, c, mu_c in results_zero_mobility:
        assert np.allclose(c, initial_concentration)
        
###############################save_results_csv############################### 

def test_save_results_csv():
    """
    This function generates mock simulation results by evolving the 
    Cahn-Hilliard model and saves the results to a CSV file. It then 
    reads the data back from the CSV file to verify that the saved 
    data matches the original simulation results. The test checks 
    that the number of entries is correct and that the values for 
    time, concentration, and chemical potential are consistent.
    
    Parameters:
    -----------
    None 
    
    Assertions:
    -----------
    - Asserts that the number of entries is the same between 
      the original results and the loaded data.
    - Asserts that the values of the entries are the same between 
      the original results and the loaded data.
    """
    # Step 1: Create results
    Nx, Ny = 10, 10
    c = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    original_results = Cahn_Hilliard.evolve_simulation(c, nstep, nprint, dtime, 
                                                       mobility, grad_coef, 
                                                       A, dx, dy)
    # Step 2: Save to CSV
    filename = 'test_save_results.csv'
    Cahn_Hilliard.save_results_csv(original_results, filename)

    # Step 3: Load back the data to verify
    loaded_df = pd.read_csv(filename)
    
    # Check the number of entries
    assert len(original_results) == len(loaded_df)

    # Check each entry
    for index, (orig_time, orig_c, orig_mu_c) in enumerate(original_results):
        loaded_row = loaded_df.iloc[index]
        assert np.isclose(orig_time, loaded_row['Time'])
        assert np.array_equal(orig_c.flatten(), 
                              np.fromstring(loaded_row['Concentration'].strip('[]'), 
                              sep=',', dtype=float))
        assert np.array_equal(orig_mu_c.flatten(), 
                              np.fromstring(loaded_row['Chemical Potential'].strip('[]'), 
                              sep=',', dtype=float))
    # Clean up
    os.remove(filename)

#############################load_results_from_csv############################# 

def test_load_results_from_csv():
    """
    This function generates mock simulation results by evolving the 
    Cahn-Hilliard model, saves the results to a CSV file, and then 
    tests the loading functionality of the load_results_from_csv function. 
    It verifies that the loaded data matches the original simulation results. 
    The test checks that the number of entries is correct and that 
    the values for time, concentration, and chemical potential 
    
    Parameters:
    -----------
    None 
    
    Assertions:
    -----------
    - Asserts that the number of entries is the same between 
      the original results and the loaded data.
    - Asserts that the values of the entries are the same between 
      the original results and the loaded data.
    """
    # Step 1: Create results
    Nx, Ny = 10, 10
    c = Cahn_Hilliard.add_fluctuation(Nx, Ny, c0, dc)
    original_results = Cahn_Hilliard.evolve_simulation(c, nstep, nprint, dtime, 
                                              mobility, grad_coef, A, dx, dy)
    # Step 2: Save to CSV
    filename = 'test_load_results.csv'
    Cahn_Hilliard.save_results_csv(original_results, filename)

    # Step 3: Load from CSV
    loaded_results = Cahn_Hilliard.load_results_from_csv(Nx, Ny, filename)

    # Check the number of entries
    assert len(original_results) == len(loaded_results)
    
    # Check each entry
    for (orig_time, 
         orig_c, orig_mu_c), (loaded_time, 
                              loaded_c, loaded_mu_c) in zip(original_results, 
                                                            loaded_results):
        assert np.isclose(orig_time, loaded_time)
        assert np.array_equal(orig_c, loaded_c)
        assert np.array_equal(orig_mu_c, loaded_mu_c)

    # Clean up
    os.remove(filename)